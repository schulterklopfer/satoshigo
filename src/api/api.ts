/*
 * MIT License
 *
 * Copyright (c) 2021 schulterklopfer/__escapee__
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILIT * Y, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Satoshi Go - API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.1.13
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import {Configuration} from './configuration';

const BASE_PATH = 'https://satoshigo.skp.rocks'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface Area
 */
export interface Area {
  /**
   *
   * @type {string}
   * @memberof Area
   */
  hash: string;
  /**
   *
   * @type {number}
   * @memberof Area
   */
  lon?: number;
  /**
   *
   * @type {number}
   * @memberof Area
   */
  lat?: number;
  /**
   * in meters
   * @type {number}
   * @memberof Area
   */
  radius?: number;
  /**
   *
   * @type {string}
   * @memberof Area
   */
  gameHash: string;
  /**
   *
   * @type {ItemDictionary}
   * @memberof Area
   */
  items: ItemDictionary;
}
/**
 * a (key, Area) map. `default`is an example key
 * @export
 * @interface AreaDictionary
 */
export interface AreaDictionary extends null<String, Area> {
  [key: string]: Area;
}
/**
 *
 * @export
 * @interface BalanceResponse
 */
export interface BalanceResponse {
  /**
   *
   * @type {number}
   * @memberof BalanceResponse
   */
  balance: number;
  /**
   *
   * @type {string}
   * @memberof BalanceResponse
   */
  withdrawStatus?: BalanceResponse.WithdrawStatusEnum;
  /**
   *
   * @type {string}
   * @memberof BalanceResponse
   */
  withdrawId?: string;
  /**
   *
   * @type {string}
   * @memberof BalanceResponse
   */
  withdrawError?: string;
}

/**
 * @export
 * @namespace BalanceResponse
 */
export namespace BalanceResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum WithdrawStatusEnum {
    Pending = <any>'pending',
    Error = <any>'error',
  }
}
/**
 *
 * @export
 * @interface CollectItemResponse
 */
export interface CollectItemResponse {
  /**
   *
   * @type {string}
   * @memberof CollectItemResponse
   */
  status: CollectItemResponse.StatusEnum;
  /**
   *
   * @type {string}
   * @memberof CollectItemResponse
   */
  itemHash?: string;
  /**
   *
   * @type {string}
   * @memberof CollectItemResponse
   */
  errorMessage?: string;
}

/**
 * @export
 * @namespace CollectItemResponse
 */
export namespace CollectItemResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Error = <any>'error',
    Collected = <any>'collected',
  }
}
/**
 *
 * @export
 * @interface EnterGameBody
 */
export interface EnterGameBody {
  /**
   *
   * @type {string}
   * @memberof EnterGameBody
   */
  secret?: string;
}
/**
 *
 * @export
 * @interface FindAreasBody
 */
export interface FindAreasBody {
  /**
   * exclude areas with ids in this array from additions array, but not from removals
   * @type {Array<string>}
   * @memberof FindAreasBody
   */
  exclude?: Array<string>;
  /**
   * longitude of center location.
   * @type {number}
   * @memberof FindAreasBody
   */
  lon: number;
  /**
   * latitude of center location.
   * @type {number}
   * @memberof FindAreasBody
   */
  lat: number;
  /**
   * radius of query in meters
   * @type {number}
   * @memberof FindAreasBody
   */
  radius: number;
}
/**
 *
 * @export
 * @interface FindAreasResponse
 */
export interface FindAreasResponse {
  /**
   * longitude of center location.
   * @type {number}
   * @memberof FindAreasResponse
   */
  lon: number;
  /**
   * latitude of center location.
   * @type {number}
   * @memberof FindAreasResponse
   */
  lat: number;
  /**
   * radius of query in meters
   * @type {number}
   * @memberof FindAreasResponse
   */
  radius: number;
  /**
   * list of items, not containing items specified in the exclude array of the request
   * @type {Array<Item>}
   * @memberof FindAreasResponse
   */
  additions: Array<Item>;
  /**
   * hashes of items to remove, also containing items specified in the exclude array of the request, if they are not in the area any more
   * @type {Array<string>}
   * @memberof FindAreasResponse
   */
  removals?: Array<string>;
}
/**
 *
 * @export
 * @interface Game
 */
export interface Game {
  /**
   *
   * @type {string}
   * @memberof Game
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof Game
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof Game
   */
  description: string;
  /**
   *
   * @type {Polygon}
   * @memberof Game
   */
  area?: Polygon;
  /**
   * some icon label or url to external icon
   * @type {string}
   * @memberof Game
   */
  appearance?: string;
  /**
   *
   * @type {boolean}
   * @memberof Game
   */
  isDefault?: boolean;
  /**
   * flags for this game, for example, is it hidden, private
   * @type {ModelObject}
   * @memberof Game
   */
  flags?: ModelObject;
  /**
   *
   * @type {number}
   * @memberof Game
   */
  totalFunds?: number;
  /**
   *
   * @type {number}
   * @memberof Game
   */
  fundsCollected?: number;
}
/**
 *
 * @export
 * @interface HiScoreEntry
 */
export interface HiScoreEntry {
  /**
   *
   * @type {string}
   * @memberof HiScoreEntry
   */
  handle: string;
  /**
   *
   * @type {number}
   * @memberof HiScoreEntry
   */
  total?: number;
  /**
   *
   * @type {number}
   * @memberof HiScoreEntry
   */
  keys?: number;
  /**
   *
   * @type {number}
   * @memberof HiScoreEntry
   */
  simple?: number;
  /**
   *
   * @type {number}
   * @memberof HiScoreEntry
   */
  locked?: number;
}
/**
 *
 * @export
 * @interface Item
 */
export interface Item {
  /**
   *
   * @type {string}
   * @memberof Item
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof Item
   */
  type: Item.TypeEnum;
  /**
   *
   * @type {string}
   * @memberof Item
   */
  areaHash: string;
  /**
   *
   * @type {number}
   * @memberof Item
   */
  data: number;
  /**
   *
   * @type {string}
   * @memberof Item
   */
  appearance: Item.AppearanceEnum;
}

/**
 * @export
 * @namespace Item
 */
export namespace Item {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Simple = <any>'simple',
  }
  /**
   * @export
   * @enum {string}
   */
  export enum AppearanceEnum {
    Coin = <any>'coin',
  }
}
/**
 * a (key, Item) map. `default`is an example key
 * @export
 * @interface ItemDictionary
 */
export interface ItemDictionary extends null<String, Item> {
  [key: string]: Item;
}
/**
 *
 * @export
 * @interface Player
 */
export interface Player {
  /**
   *
   * @type {string}
   * @memberof Player
   */
  hash: string;
  /**
   *
   * @type {string}
   * @memberof Player
   */
  handle: string;
  /**
   *
   * @type {string}
   * @memberof Player
   */
  secret?: string;
  /**
   *
   * @type {string}
   * @memberof Player
   */
  gameHash: string;
  /**
   *
   * @type {boolean}
   * @memberof Player
   */
  enableHiScore?: boolean;
}
/**
 *
 * @export
 * @interface PlayerUpdateBody
 */
export interface PlayerUpdateBody {
  /**
   *
   * @type {string}
   * @memberof PlayerUpdateBody
   */
  handle: string;
  /**
   *
   * @type {boolean}
   * @memberof PlayerUpdateBody
   */
  enableHiScore?: boolean;
}
/**
 *
 * @export
 * @interface Polygon
 */
export interface Polygon {
  /**
   * list of [lon, lat] coordinates
   * @type {Array<Array<number>>}
   * @memberof Polygon
   */
  coordinates?: Array<Array<number>>;
}
/**
 *
 * @export
 * @interface WithdrawIdResponse
 */
export interface WithdrawIdResponse {
  /**
   *
   * @type {string}
   * @memberof WithdrawIdResponse
   */
  withdrawId: string;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary collects an item
     * @param {string} itemHash Id of item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectItem(itemHash: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemHash' is not null or undefined
      if (itemHash === null || itemHash === undefined) {
        throw new RequiredError(
          'itemHash',
          'Required parameter itemHash was null or undefined when calling collectItem.',
        );
      }
      const localVarPath = '/items/{itemHash}/collect'.replace(
        `{${'itemHash'}}`,
        encodeURIComponent(String(itemHash)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'POST'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication SignedPlayerHashAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('X-SIGNED-PLAYERHASH')
            : configuration.apiKey;
        localVarHeaderParameter['X-SIGNED-PLAYERHASH'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary enters a game
     * @param {EnterGameBody} body
     * @param {string} gameHash Hash of game to get hiscores from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enterGame(
      body: EnterGameBody,
      gameHash: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling enterGame.',
        );
      }
      // verify required parameter 'gameHash' is not null or undefined
      if (gameHash === null || gameHash === undefined) {
        throw new RequiredError(
          'gameHash',
          'Required parameter gameHash was null or undefined when calling enterGame.',
        );
      }
      const localVarPath = '/games/{gameHash}/enter'.replace(
        `{${'gameHash'}}`,
        encodeURIComponent(String(gameHash)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'POST'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication SignedPlayerHashAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('X-SIGNED-PLAYERHASH')
            : configuration.apiKey;
        localVarHeaderParameter['X-SIGNED-PLAYERHASH'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'EnterGameBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary finds areas in radius around point
     * @param {FindAreasBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAreas(body: FindAreasBody, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling findAreas.',
        );
      }
      const localVarPath = '/find/areas';
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'POST'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'FindAreasBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary gets player for this token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findMe(options: any = {}): FetchArgs {
      const localVarPath = '/find/me';
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'GET'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication SignedPlayerHashAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('X-SIGNED-PLAYERHASH')
            : configuration.apiKey;
        localVarHeaderParameter['X-SIGNED-PLAYERHASH'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary gets an area
     * @param {string} areaHash Id of area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArea(areaHash: string, options: any = {}): FetchArgs {
      // verify required parameter 'areaHash' is not null or undefined
      if (areaHash === null || areaHash === undefined) {
        throw new RequiredError(
          'areaHash',
          'Required parameter areaHash was null or undefined when calling getArea.',
        );
      }
      const localVarPath = '/areas/{areaHash}'.replace(
        `{${'areaHash'}}`,
        encodeURIComponent(String(areaHash)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'POST'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary gets all areas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAreas(options: any = {}): FetchArgs {
      const localVarPath = '/areas';
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'GET'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary gets your balance in milli satoshis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalance(options: any = {}): FetchArgs {
      const localVarPath = '/balance';
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'GET'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication SignedPlayerHashAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('X-SIGNED-PLAYERHASH')
            : configuration.apiKey;
        localVarHeaderParameter['X-SIGNED-PLAYERHASH'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary get a list of games
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGames(options: any = {}): FetchArgs {
      const localVarPath = '/games';
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'GET'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary gets the high score list
     * @param {string} gameHash Hash of game to get hiscores from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHiScore(gameHash: string, options: any = {}): FetchArgs {
      // verify required parameter 'gameHash' is not null or undefined
      if (gameHash === null || gameHash === undefined) {
        throw new RequiredError(
          'gameHash',
          'Required parameter gameHash was null or undefined when calling getHiScore.',
        );
      }
      const localVarPath = '/games/{gameHash}/hiscore'.replace(
        `{${'gameHash'}}`,
        encodeURIComponent(String(gameHash)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'GET'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary gets an item
     * @param {string} itemHash Id of item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItem(itemHash: string, options: any = {}): FetchArgs {
      // verify required parameter 'itemHash' is not null or undefined
      if (itemHash === null || itemHash === undefined) {
        throw new RequiredError(
          'itemHash',
          'Required parameter itemHash was null or undefined when calling getItem.',
        );
      }
      const localVarPath = '/items/{itemHash}'.replace(
        `{${'itemHash'}}`,
        encodeURIComponent(String(itemHash)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'GET'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary gets an lnurl to retrieve your milli sats from the game
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWithdrawId(options: any = {}): FetchArgs {
      const localVarPath = '/withdrawId';
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'GET'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication SignedPlayerHashAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('X-SIGNED-PLAYERHASH')
            : configuration.apiKey;
        localVarHeaderParameter['X-SIGNED-PLAYERHASH'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary leaves the game
     * @param {string} gameHash Hash of game to get hiscores from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveGame(gameHash: string, options: any = {}): FetchArgs {
      // verify required parameter 'gameHash' is not null or undefined
      if (gameHash === null || gameHash === undefined) {
        throw new RequiredError(
          'gameHash',
          'Required parameter gameHash was null or undefined when calling leaveGame.',
        );
      }
      const localVarPath = '/games/{gameHash}/leave'.replace(
        `{${'gameHash'}}`,
        encodeURIComponent(String(gameHash)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'POST'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication SignedPlayerHashAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('X-SIGNED-PLAYERHASH')
            : configuration.apiKey;
        localVarHeaderParameter['X-SIGNED-PLAYERHASH'] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary registers a new player
     * @param {PlayerUpdateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerPlayer(body: PlayerUpdateBody, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling registerPlayer.',
        );
      }
      const localVarPath = '/players';
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'POST'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'PlayerUpdateBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary updates a player
     * @param {PlayerUpdateBody} body
     * @param {string} playerHash Hash of player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePlayer(
      body: PlayerUpdateBody,
      playerHash: string,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updatePlayer.',
        );
      }
      // verify required parameter 'playerHash' is not null or undefined
      if (playerHash === null || playerHash === undefined) {
        throw new RequiredError(
          'playerHash',
          'Required parameter playerHash was null or undefined when calling updatePlayer.',
        );
      }
      const localVarPath = '/players/{playerHash}'.replace(
        `{${'playerHash'}}`,
        encodeURIComponent(String(playerHash)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({method: 'POST'}, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication SignedPlayerHashAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? configuration.apiKey('X-SIGNED-PLAYERHASH')
            : configuration.apiKey;
        localVarHeaderParameter['X-SIGNED-PLAYERHASH'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'PlayerUpdateBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary collects an item
     * @param {string} itemHash Id of item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectItem(
      itemHash: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CollectItemResponse> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).collectItem(itemHash, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary enters a game
     * @param {EnterGameBody} body
     * @param {string} gameHash Hash of game to get hiscores from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enterGame(
      body: EnterGameBody,
      gameHash: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Game> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).enterGame(body, gameHash, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary finds areas in radius around point
     * @param {FindAreasBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAreas(
      body: FindAreasBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<FindAreasResponse> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).findAreas(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary gets player for this token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findMe(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
      const localVarFetchArgs =
        DefaultApiFetchParamCreator(configuration).findMe(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary gets an area
     * @param {string} areaHash Id of area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArea(
      areaHash: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Area> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).getArea(areaHash, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary gets all areas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAreas(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AreaDictionary> {
      const localVarFetchArgs =
        DefaultApiFetchParamCreator(configuration).getAreas(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary gets your balance in milli satoshis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalance(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BalanceResponse> {
      const localVarFetchArgs =
        DefaultApiFetchParamCreator(configuration).getBalance(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary get a list of games
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGames(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Game>> {
      const localVarFetchArgs =
        DefaultApiFetchParamCreator(configuration).getGames(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary gets the high score list
     * @param {string} gameHash Hash of game to get hiscores from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHiScore(
      gameHash: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<HiScoreEntry>> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).getHiScore(gameHash, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary gets an item
     * @param {string} itemHash Id of item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItem(
      itemHash: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Item> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).getItem(itemHash, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary gets an lnurl to retrieve your milli sats from the game
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWithdrawId(
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<WithdrawIdResponse> {
      const localVarFetchArgs =
        DefaultApiFetchParamCreator(configuration).getWithdrawId(options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary leaves the game
     * @param {string} gameHash Hash of game to get hiscores from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveGame(
      gameHash: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Game> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).leaveGame(gameHash, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary registers a new player
     * @param {PlayerUpdateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerPlayer(
      body: PlayerUpdateBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).registerPlayer(body, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary updates a player
     * @param {PlayerUpdateBody} body
     * @param {string} playerHash Hash of player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePlayer(
      body: PlayerUpdateBody,
      playerHash: string,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration,
      ).updatePlayer(body, playerHash, options);
      return (
        fetch: FetchAPI = portableFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary collects an item
     * @param {string} itemHash Id of item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    collectItem(itemHash: string, options?: any) {
      return DefaultApiFp(configuration).collectItem(itemHash, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary enters a game
     * @param {EnterGameBody} body
     * @param {string} gameHash Hash of game to get hiscores from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enterGame(body: EnterGameBody, gameHash: string, options?: any) {
      return DefaultApiFp(configuration).enterGame(
        body,
        gameHash,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary finds areas in radius around point
     * @param {FindAreasBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAreas(body: FindAreasBody, options?: any) {
      return DefaultApiFp(configuration).findAreas(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary gets player for this token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findMe(options?: any) {
      return DefaultApiFp(configuration).findMe(options)(fetch, basePath);
    },
    /**
     *
     * @summary gets an area
     * @param {string} areaHash Id of area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArea(areaHash: string, options?: any) {
      return DefaultApiFp(configuration).getArea(areaHash, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary gets all areas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAreas(options?: any) {
      return DefaultApiFp(configuration).getAreas(options)(fetch, basePath);
    },
    /**
     *
     * @summary gets your balance in milli satoshis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBalance(options?: any) {
      return DefaultApiFp(configuration).getBalance(options)(fetch, basePath);
    },
    /**
     *
     * @summary get a list of games
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGames(options?: any) {
      return DefaultApiFp(configuration).getGames(options)(fetch, basePath);
    },
    /**
     *
     * @summary gets the high score list
     * @param {string} gameHash Hash of game to get hiscores from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHiScore(gameHash: string, options?: any) {
      return DefaultApiFp(configuration).getHiScore(gameHash, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary gets an item
     * @param {string} itemHash Id of item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItem(itemHash: string, options?: any) {
      return DefaultApiFp(configuration).getItem(itemHash, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary gets an lnurl to retrieve your milli sats from the game
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWithdrawId(options?: any) {
      return DefaultApiFp(configuration).getWithdrawId(options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary leaves the game
     * @param {string} gameHash Hash of game to get hiscores from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaveGame(gameHash: string, options?: any) {
      return DefaultApiFp(configuration).leaveGame(gameHash, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary registers a new player
     * @param {PlayerUpdateBody} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerPlayer(body: PlayerUpdateBody, options?: any) {
      return DefaultApiFp(configuration).registerPlayer(body, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary updates a player
     * @param {PlayerUpdateBody} body
     * @param {string} playerHash Hash of player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePlayer(body: PlayerUpdateBody, playerHash: string, options?: any) {
      return DefaultApiFp(configuration).updatePlayer(
        body,
        playerHash,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @summary collects an item
   * @param {string} itemHash Id of item.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public collectItem(itemHash: string, options?: any) {
    return DefaultApiFp(this.configuration).collectItem(itemHash, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary enters a game
   * @param {EnterGameBody} body
   * @param {string} gameHash Hash of game to get hiscores from.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public enterGame(body: EnterGameBody, gameHash: string, options?: any) {
    return DefaultApiFp(this.configuration).enterGame(
      body,
      gameHash,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary finds areas in radius around point
   * @param {FindAreasBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public findAreas(body: FindAreasBody, options?: any) {
    return DefaultApiFp(this.configuration).findAreas(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary gets player for this token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public findMe(options?: any) {
    return DefaultApiFp(this.configuration).findMe(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary gets an area
   * @param {string} areaHash Id of area.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getArea(areaHash: string, options?: any) {
    return DefaultApiFp(this.configuration).getArea(areaHash, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary gets all areas
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAreas(options?: any) {
    return DefaultApiFp(this.configuration).getAreas(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary gets your balance in milli satoshis
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getBalance(options?: any) {
    return DefaultApiFp(this.configuration).getBalance(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary get a list of games
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getGames(options?: any) {
    return DefaultApiFp(this.configuration).getGames(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary gets the high score list
   * @param {string} gameHash Hash of game to get hiscores from.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getHiScore(gameHash: string, options?: any) {
    return DefaultApiFp(this.configuration).getHiScore(gameHash, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary gets an item
   * @param {string} itemHash Id of item.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getItem(itemHash: string, options?: any) {
    return DefaultApiFp(this.configuration).getItem(itemHash, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary gets an lnurl to retrieve your milli sats from the game
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getWithdrawId(options?: any) {
    return DefaultApiFp(this.configuration).getWithdrawId(options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary leaves the game
   * @param {string} gameHash Hash of game to get hiscores from.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public leaveGame(gameHash: string, options?: any) {
    return DefaultApiFp(this.configuration).leaveGame(gameHash, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary registers a new player
   * @param {PlayerUpdateBody} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public registerPlayer(body: PlayerUpdateBody, options?: any) {
    return DefaultApiFp(this.configuration).registerPlayer(body, options)(
      this.fetch,
      this.basePath,
    );
  }

  /**
   *
   * @summary updates a player
   * @param {PlayerUpdateBody} body
   * @param {string} playerHash Hash of player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updatePlayer(
    body: PlayerUpdateBody,
    playerHash: string,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration).updatePlayer(
      body,
      playerHash,
      options,
    )(this.fetch, this.basePath);
  }
}
